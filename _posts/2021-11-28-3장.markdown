---
layout: post
title:  "03장 도메인 논리 구성"
date:   2021-11-28 23:17:03 +0900
categories: jekyll update
---
- 관계형 데이터 베이스란 우리가 흔히 말하는 DB(ex:db2) 를 말하는것 같다.데이터 원본 계층에서 가장 중요한 일은 데이터베이스와 상호 작용하는 것이며 아래에서 여러 패턴에 대해서 알아보자
1. 게이트웨이  : SQL 접근을 도메인 논리와는 별도로 불리하고 개별 클래스에 배치 하는 것이 좋다. 이런 클래스를  데이터베이스 테이블당 클래스 하나를 가지도록 구성한 것.
	- 게이트웨이를 구성한는 이유 : SQL을 쉽게 찾을 수 있게 하여 데이터 베이스에 전문 지식이 있는 개발자는 이런 특화 클래스에 집중하게 하고 애플리케이션 나머지 부분에서는 SQL에 대해 알 필요가 없게 하기 위함.
	- 행 데이터 게이트웨이  : 쿼리가 반환하는 각 행마다 인스턴스 하나를 만드는 것.
	- 테이블 데이터 게이트웨이 :  테이블당 인스턴스 하나를 만드는 것, 데이터 베이스를 쿼리하고 레코드 집합을 반환하는 메서드를 제공.
		- 레코드 집합  : 데이터베이스의 테이블식 특성을 흉내 낸 테이블과 행의 범용 자료구조
	- 게이트웨이 적용사례
		- 테이블 모듈에서 테이블 데이터 게이트웨이를 사용하는 것이 적합. 저장 프로시저를 정리하는데도 이 패턴을 고려할 수 있다.
		- 도메인 모델에서 사용할 때
			- 활성 레코드 구조를 이용한 사례 : 활성레코드란 데이터베이스 테이블이나 뷰의 행을 래핑하고, 데이터 베이스 접근을 캡슐화하며, 해당 데이터에 대한 도메인 논리를 추가하는 객체,  간단한 애플리케이션에서 활용하는게 적절.
				- 단점 1: 도메인 논리가 복잡해지면 점차 리치 도메인( 뭔가 안좋은 거에는 리치를 붙인거를 봐서는 좋은 의미는 아닌거 같음)에 가까워지고 활성 레코드의 간단한 접근법으로는 주체 못하게 된다.
				- 단점 2: 관계형 데이터 베이스에서는 상속을 지원하지 않으므로 객채지향 패턴을 적용하기 어렵다.
				- 단점 3: 도메인 논리를 개발하는동안 데이터베이스와 상호 작용하지 않고도 도메인 논리를 테스트 할 수 있는 방법이 필요. 
			- 데이터 매퍼를 이용한 사례 : 데이터 매퍼란 객체와  데이터베이스 사이에서 둘 사이는 물론 매퍼 자체에 대한 독립성을 유지하면서 데이터를 옮기는 메퍼의 한계층이다. 도메인 모델을 데이터베이스로부터 격리하여 서로 독립적으로 작동할 수있게 중간에서 로직을 처리한다. 복잡한 논리에서 사용이 적합.
2. 객체지향 데이터 베이스 : 객체지향 초창기에 객체와 관계간 근본적인 임피던스 부정합 이 있다는것을 깨닫고 객체지향 데이터 베이스를 만들었다.
		- 인피던스 부정합(impedance mismatch) : 기존 관계형 데이터베이스의 SQL과 프로그래밍 언어 사이에 데이터 구조, 기능 등의 차이로 발생하는 충돌.
	- 객체지향 데이터 베이스의 장점으로는 생산성 향상을 들 수 있다.
		1. 매핑을 신경 쓸 필요가 없다.
		2. 상호 연결된 거대한 객체의 구조를 그대로 사용할 수 있다.
		3. 객체를 저장하고 가져오는 작업을 데이터베이스가 알아서 처리한다. 
		4. 트랜잭션을 이용해 데이터 저장소의 업데이트와 공유 허용을 그룹화 할 수 있다.
	- 이미 입증된 관계형 데이터 베이스에 비해 위험성이 높아 널리 사용되지 않는다.
	- 객체지향 데이터 베이스를 사용할 수 없더라도 설계에 도메인 모델이 있다면 O/R 매핑 툴(ex : 하이버네이트)을 도입하는것을 고려해야 함.
		- O/R 매핑  : 객체 관계 매핑(Object-relational mapping; ORM)은 데이터베이스와 객체 지향 프로그래밍 언어 간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법이다. 객체 지향 언어에서 사용할 수 있는 "가상" 객체 데이터베이스를 구축하는 방법이다.
3. 동작 문제
	- 추적 문제 : 다수의 객체를 메모리로 로드하고 수정할 때는 객체를 데이터베이스에 올바르게 기록하기 위해 수정한 객체를 모두 추적해야 된다. 복잡한 상황에서 고려해야 되는 것이 많다.(ex : 새로 생성된 행을 참조하는 다른행을 수정하는 상황)
	- 동시성 문제 : 객체를 읽고 이를 대상으로 작업할 때는 다른 프로세스가 이 객체를 변경하지 못하도록 읽기를 격리해야 한다. 그렇지 않으면 일관성 문제가 발생하고 객체에 잘못된 데이터가 저장될 수 있다.
	- 작업 단위 :  위 두가지 문제를 해결하기 위해 꼭 필요한 패턴이다. 작업단위는 비즈니스 트랜잭션의 영향을 받은 객체의 리스르를 유지 관리하고, 변경 내용을 기록하는 일과 동시성 문제를 해결하는 일을 조율한다.
	- 객체를 로드할때 같은 객체를 두번 로드하지 않게 주의해야 한다. 같은 객체를 두번 로드하면 업데이트 같은 상황에서 예기치 못한 결과가 발생된다. 해당 문제는 식별자 맵을 사용해 해결가능 식별자 맵은 모든 객체를 한 맵에 로드해 각 객체가 한번씩만 로드되게 한다.객체를 참조할 때는 맵을 이용해 객체를 조회한다.
	- 여러 객체가 복잡하게 상호 연결된 겨우 어떤 객체를 읽더라도 데이터베이스에 막대한 규모의 객체 그래프가 선택될 수 있다. 해당 상황을 해결하기 위해 지연 로드를 사용 지연로드는 객체 참조 대신 자리표시자를 이용하는 기법.
4. 데이터 읽기
	- 데이터베이스와 상호작용하는 클래스가  테이블 기반인 경우 데이터베이스의 테이블마다 클래스 인스턴스가 하나씩 있으므로 검색기 메서드(SQL select)를 삽입 및 업데이 트와 결합하는 방법을 쓸수 있다.
	- 행기반 클래스를 사욯나는 경우 검색 작업을 정적으로 만들 수 있지만 데이터베이스 작업을 대체할 수 없게 된다. 이 문제를 해결하는 가장 좋은 방법은 검색기 객첼르 별도로 만드는 것이다.
	- 데이터 베이스 성능 문제로 고려해야 되는 사항.
		- 가급적 여러행을 한 번에 읽는다. 특히 같은 테이블에서 여러 행을 읽기 위해 반복적으로 쿼리하는일이 없게 해야 한다.
		- 조인을 사용해 쿼리 하나로 여러 테이블을 한번에 가져 오게하여 성능을 향상. 조인은 쿼리당 최대 3-4개  조인 사용 더 많이 사용하면 성능 저하의 요인이 된다.
		- 그외 다양한 최적화 : 클러스터링, 세심한 인덱스 사용, 메모리 캐시 활용.
5. 구조적 매핑 패턴
	- 관계 매핑 : 객체와 관계형 데이터베이스를 처리하는 방법에는 차이가 있으며, 이 때문에 두가지 문제가 밸생된다.
		- 참조 방법의 차이: 객체는 참조 를 저장한는 방법으로 연결을 처리한다. 관계형 데이터베이스는 다른 테이블의 대한 키를 생성해 연결을 처리한다.
		- 객체는 컬렉션을 사용해 단일 필드로 손쉽게 여러 참조를 처리 할 수 있는 반면 관계형은 정규화를 지원하기 위해 모든 연관 링크가 단일 값을 가져야 한다.
	- 상속 : SQL에는 상속을 처리하는 표준적인 방법이 없기 때문에 이 경우에도 매핑을 이용해야 한다.
	- 상속을 처리하는 3가지 방법
		- 단일 테이블 상속 : 모든 클래스에 대해 테이블 하나를 사용
		- 구현 테이블 상속 : 각 구현 클래스당 테이블 하나를 사용
		- 클래스 테이블 상속 :  계층의 클래스당 테이블 하나를 사용
6. 매핑
	- 관계형 데이터 베이스로 매핑할 때는 기본적으로 세가지 상황중 하나에 해당한다.
		- 스키마를 직접 선택할 수 있다.
		- 기존의 스키마로 매핑해야 하며, 스키마를 변경할 수 없다.
		- 기존의 스키마로 매핑해야 하지만 합의를 통해 스키마를 변경할 수 있다.
	- 가장 간단한 경우는 스키마를 직접 만들며, 중간 또는 낮은 복자도의 도메인 논리를 위해 설계에 트랜잭션 스크립트나 테이블 모듈을 사욯하는 경우는 도메인 놀리에서 SQL을 가져오는 데는 행 데이터 게이트웨이나 테이블 데이터 게이트웨이를 사욯한다.
	- 도메인 모델을 사용할 때는 도메인 논리를 간소화하는데 집중하면서 도메인 모델을 구축한다. 데이터베이스 설계는 객체의 데이터를 지속하는 방법으로 취급한다. 데이터 매퍼는 유연성은 높지만 복잡하므로 활성 레코드 사용을 고려해야 함.
	- 스키마가 이미 있는 경우
		- 도메인 논리가 간단할 경우 : 데이터베이스를 모방하는 행 데이터 게이트웨이나 테이블 데이터 게이트웨이 클래스를 만들고 이 위에 도메인 논리를 배치한다.
		- 도메인 논리가 복잡할 경우 : 도메인 모델이 필요하며, 이 도메인 모델은 데이터베이스 설계와는 일치하지 않을 가능성이 높다. 따라서 도메인 모델을 점진적으로 구축하면서 데이터를 기존 데이터베이스에 저장할 데이터 매퍼를 포함하면 된다.
	- 이중 매핑
		- 이중 맵핑을 사용해야 되는 케이스 
			1. 여러 데이터베이스에 동일한 데이터가 포함되지만 복사/붙여넣기 재사용 방법  때문에 스미카에 차이가 있는 경우
			2. 다른 메커니즘으로 저장하는 경우, 데이터를 데이터 베이스에 저장하거나 때로는 메시지(xml 메시지, cicis 트랜잭션)에 저장하는 경우.
		- 이중 맵핑 구현방법
			1. 가장 간단한 방법은  데이터 원본마다 하나씩, 매핑 계층을 여러개로 만든 것. 데이터가 아주 비슷한 경우 코드 중복이 심해 질수 있다.
			2. 2단계 매핑 스키마
				- 첫번째 단계는 데이터를 인메모리 스키마에서 논리적 데이터 자장소 스키마로 변환
				- 두번째 단계는 논리적 데이터 저장소 스키마에서 실제 물리적 데이터 자장소 스키마로 매핑
7. 메타데이터 사용
	- 메타데이터 매핑 :  데이터베이스의 열이 객체의 필드에 매핑되는 구체적인 방법을 메타데이터 파일에 기록하는 것이다. 핵심은 일단 메타데이터를 만든 후에는 코드 생성이나 리플렉션 프로그래밍을 통해 반복적 코드를 대신할 수 있다는 것이다.
		- 리플렉션 : 리플렉션이란 객체를 통해 클래스의 정보를 분석해 내는 프로그램 기법을 말한다. (투영, 반사 라는 사전적인 의미를 지니고 있다.)
	- 메타데이터 매핑은 인메모리 객체를 얻는 쿼리를 작성하는데 필요한 기반 정보를 제공한다. 
	- 쿼리 객체는 메타데이터 매핑을 이용해 객체 필드에 필요한 정보를 적절한 SQL로 변환 한다. 이를 더 발전시켜 뷰에서 데이터 베이스를 볼수 없게 하는 리포지토리를 만들 수 있다. 리포지토리는 리치 도메인 시스템과 아주 잘어울린다.
		- 리포지토리 :  도메인 객체에 접근하는 컬렉션과 비슷한 인터페이스를 사용해 도메인과 데이터 매핑 계층 사이를 중재한다.
8. 데이터베이스 연결
	- 대부분의 데이터베이스 인터페이스는 애플리케이션 코드와 데이터베이스 간의링크 역활을 하는 일종의 데이터베이스 연결 객체를 사용한다. 이러한 연결을 먼저 열어야 데이터베이스에 대한 명령을 실행 할 수 있다. 
	- 연결을 만드는 데 드는 비용을 절약하기 위해 연결 풀(jdbc connector?)을 사용하는 경우가 많다. 이경우 개발자는 직접 연결을 만들고 닫는 대신 연결이 필요할 때 풀에서 요청하며 작업이 끝나면 연결을 풀로 반환한다.
	- 연결은 만드는 비용이 크든 작든 관리가 필요하다. 연결은 관리하는데 비용이 많이 발생 사용이 끝나면 즉시 닫아야 한다.
	- 연결이 필요한 모든곳에서 연결을 확보하는 방법
		1. 연결을 명시적 매개변수로 전달하는 것 : 이 방법의 문제는 불필요하게 모든 종유의 메서드 호출에 연경을 함께 전달해야 한다는 것이다. 이 문제는 레지스트리를 사용해 해결할 수 있다.
		2. 트랜잭션과 함께 연결을 관리하는 것 : 트랜잭션을 시작할 때 연경을 열고, 커밋하거나 롤백할 때 연결을 닫는다.
9. 기타 주의사항
	- select * from 형식 : 새열이 추가되거나 열이 재정렬 되면 일부 데이터베이스 드라이버에서 심각한 문제를 발생할 수 있다. 인덱슬르 사용해 열에서 정보를 얻을때는 사용하지 않는 편이 좋다.