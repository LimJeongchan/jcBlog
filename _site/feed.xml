<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-11-18T00:50:08+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">임정찬의 블로그</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">01장 계층화</title><link href="http://localhost:4000/jekyll/update/2021/11/17/1%EC%9E%A5.html" rel="alternate" type="text/html" title="01장 계층화" /><published>2021-11-17T13:51:03+09:00</published><updated>2021-11-17T13:51:03+09:00</updated><id>http://localhost:4000/jekyll/update/2021/11/17/1%EC%9E%A5</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2021/11/17/1%EC%9E%A5.html">&lt;ol&gt;
  &lt;li&gt;계층화 정의 : 소프트웨어 설계자가 복잡한 소프트웨어 시스템을 분할하는 데 사용하는 가장 일반적인 기법.&lt;/li&gt;
  &lt;li&gt;계층화의 장점
    &lt;ul&gt;
      &lt;li&gt;다른 계층에 대한 정보 없이도 단일 계층을 하나의 일관된 계층으로 이해할 수 있다.&lt;/li&gt;
      &lt;li&gt;동일한 기본 서비스를 가진 대안 구현으로 계층을 대체할 수 있다.&lt;/li&gt;
      &lt;li&gt;계층 간의 의존성을 최소화할 수 있다.&lt;/li&gt;
      &lt;li&gt;계층은 표준화하기 좋은 위치다.&lt;/li&gt;
      &lt;li&gt;한번 구축한 계층은 여러 다른 상위 서비스에서 사용할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;계층화의 단점
    &lt;ul&gt;
      &lt;li&gt;계층은 전체가 효과적으로 캡슐화되지 않는다. 그 결과, 뭔가를 변경했을 때 다른 계층에 영향을 미치는 경우가 있다.&lt;/li&gt;
      &lt;li&gt;계층을 추가하면 성능이 저하된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;엔터프라이즈 애플리케이션에서 계층의 발전
    &lt;ul&gt;
      &lt;li&gt;일괄 처리 시스템
        &lt;ul&gt;
          &lt;li&gt;이시절 계층화는 그리 중요한 개념이 아님,  ISAMS, VSAM등 파일을 조작하는 것으로 충분했기 때문&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;90년대 클라이언트-서버 시스템의 등장
        &lt;ul&gt;
          &lt;li&gt;클라이언트-서버 시스템이란 클라이언트가 사용자 인터페이스와 다른 애플리케이션 코드를 포함하고 서버가 관계형 데이터베이스를 포함하는 2계층 시스템&lt;/li&gt;
          &lt;li&gt;단순 업데이트 하는 간단한 기능을 수행하는데 적합.&lt;/li&gt;
          &lt;li&gt;문제점 1 : 도메인 논리(계산, 유효성 검사, 계산 등) 변경이 이루어 졌을 때 수많은 코드를  찾아야 함.&lt;/li&gt;
          &lt;li&gt;문제점 2: 문제점 1대안으로 프로시저를 만들었는데 프로시저는 공급 업체별로 다르기 때문에 종속성 문제가 발생.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;객체지향 세계의 시작과 웹의 등장
        &lt;ul&gt;
          &lt;li&gt;객체지향 커뮤니티에서 도메인 논리에 대한 해결책으로 3계층 시스템을 제안.&lt;/li&gt;
          &lt;li&gt;웹의 등장으로 웹배포를 위한 3계층 시스템 도입이 필요하게 되었다.
            &lt;ul&gt;
              &lt;li&gt;티어 : 물리적 분리를 함축하는 경우. (ex : 클라이언트-서버 시스템 은 2계층)&lt;/li&gt;
              &lt;li&gt;계층 : 다른시스템에서 실행할 필요가 없음을 강조하기 위해 계층이라는 용어를 사용&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;세 가지 주요 계층
    &lt;ul&gt;
      &lt;li&gt;프레젠테이션 :서비스 제공, 정보 표시(창 또는 HTML),  사용자 요청(마우스 클릭, 키누름), HTTP 요청, 명령줄 호출, 일괄 작업 API 처리&lt;/li&gt;
      &lt;li&gt;도메인 : 시스템의 핵심이 되는 논리&lt;/li&gt;
      &lt;li&gt;데이터 원본 : 데이터 베이스, 메시징 시스템, 트랜잭션 관리자 및 다른 패키지와 의 통신&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;계층이 실행될 위치 선택
    &lt;ul&gt;
      &lt;li&gt;서버에서 모든걸 실행했을 때의 장점
        &lt;ul&gt;
          &lt;li&gt;업그레이드나 수정이 쉽다.&lt;/li&gt;
          &lt;li&gt;데스크톱 서버 동기화를 신경쓰지 않아도 된다.&lt;/li&gt;
          &lt;li&gt;다른 데스크톱 소프트웨어와의 호환성 문제도 없다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;클라이언트에서 모든걸 실행했을 때의 장점
        &lt;ul&gt;
          &lt;li&gt;응답성이나 비연결 작업이 유리함.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;계층별로 실행 할 수 있는 위치 선택
        &lt;ul&gt;
          &lt;li&gt;프레젠테이션 계층 : 사용자 인터페이스의 유형에 따라 달라진다. 리치 클라이언트의 경우 대부분 클라이언트에서 실행, 웹 인터페이스의 경우 거의 대부분 서버에서 실행. 특별한 사유가 없으면 웹에서 실행되는 프레젠 테이션을 권장.&lt;/li&gt;
          &lt;li&gt;도메인 논리 계층 : 서버 , 클라이언트 모두 실행 가능 하나 서버에서 실행하는 것이 유지 관리를 생각할 때 최선의 방법 모든 논리를 한곳에서 관리 할 수 있기 때문. 일부 클라이언트에서 실행할 경우 다른 시스템에 의존하지 않는 독립적 모듈로 만들 것.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html">계층화 정의 : 소프트웨어 설계자가 복잡한 소프트웨어 시스템을 분할하는 데 사용하는 가장 일반적인 기법. 계층화의 장점 다른 계층에 대한 정보 없이도 단일 계층을 하나의 일관된 계층으로 이해할 수 있다. 동일한 기본 서비스를 가진 대안 구현으로 계층을 대체할 수 있다. 계층 간의 의존성을 최소화할 수 있다. 계층은 표준화하기 좋은 위치다. 한번 구축한 계층은 여러 다른 상위 서비스에서 사용할 수 있다. 계층화의 단점 계층은 전체가 효과적으로 캡슐화되지 않는다. 그 결과, 뭔가를 변경했을 때 다른 계층에 영향을 미치는 경우가 있다. 계층을 추가하면 성능이 저하된다. 엔터프라이즈 애플리케이션에서 계층의 발전 일괄 처리 시스템 이시절 계층화는 그리 중요한 개념이 아님, ISAMS, VSAM등 파일을 조작하는 것으로 충분했기 때문 90년대 클라이언트-서버 시스템의 등장 클라이언트-서버 시스템이란 클라이언트가 사용자 인터페이스와 다른 애플리케이션 코드를 포함하고 서버가 관계형 데이터베이스를 포함하는 2계층 시스템 단순 업데이트 하는 간단한 기능을 수행하는데 적합. 문제점 1 : 도메인 논리(계산, 유효성 검사, 계산 등) 변경이 이루어 졌을 때 수많은 코드를 찾아야 함. 문제점 2: 문제점 1대안으로 프로시저를 만들었는데 프로시저는 공급 업체별로 다르기 때문에 종속성 문제가 발생. 객체지향 세계의 시작과 웹의 등장 객체지향 커뮤니티에서 도메인 논리에 대한 해결책으로 3계층 시스템을 제안. 웹의 등장으로 웹배포를 위한 3계층 시스템 도입이 필요하게 되었다. 티어 : 물리적 분리를 함축하는 경우. (ex : 클라이언트-서버 시스템 은 2계층) 계층 : 다른시스템에서 실행할 필요가 없음을 강조하기 위해 계층이라는 용어를 사용 세 가지 주요 계층 프레젠테이션 :서비스 제공, 정보 표시(창 또는 HTML), 사용자 요청(마우스 클릭, 키누름), HTTP 요청, 명령줄 호출, 일괄 작업 API 처리 도메인 : 시스템의 핵심이 되는 논리 데이터 원본 : 데이터 베이스, 메시징 시스템, 트랜잭션 관리자 및 다른 패키지와 의 통신 계층이 실행될 위치 선택 서버에서 모든걸 실행했을 때의 장점 업그레이드나 수정이 쉽다. 데스크톱 서버 동기화를 신경쓰지 않아도 된다. 다른 데스크톱 소프트웨어와의 호환성 문제도 없다. 클라이언트에서 모든걸 실행했을 때의 장점 응답성이나 비연결 작업이 유리함. 계층별로 실행 할 수 있는 위치 선택 프레젠테이션 계층 : 사용자 인터페이스의 유형에 따라 달라진다. 리치 클라이언트의 경우 대부분 클라이언트에서 실행, 웹 인터페이스의 경우 거의 대부분 서버에서 실행. 특별한 사유가 없으면 웹에서 실행되는 프레젠 테이션을 권장. 도메인 논리 계층 : 서버 , 클라이언트 모두 실행 가능 하나 서버에서 실행하는 것이 유지 관리를 생각할 때 최선의 방법 모든 논리를 한곳에서 관리 할 수 있기 때문. 일부 클라이언트에서 실행할 경우 다른 시스템에 의존하지 않는 독립적 모듈로 만들 것.</summary></entry><entry><title type="html">싱글톤 패턴</title><link href="http://localhost:4000/jekyll/update/2021/11/17/Singleton.html" rel="alternate" type="text/html" title="싱글톤 패턴" /><published>2021-11-17T13:33:03+09:00</published><updated>2021-11-17T13:33:03+09:00</updated><id>http://localhost:4000/jekyll/update/2021/11/17/Singleton</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2021/11/17/Singleton.html">&lt;ul&gt;
  &lt;li&gt;목표 : 싱글톤 패턴에 대해서 공부하여 자료를 만들고 스터디 그룹에서 발표한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Singleton 의 사전적 의미
    &lt;ul&gt;
      &lt;li&gt;(단독) 개체, 독신자(결혼을 안 했거나 애인이 없는 사람) , (쌍둥이가 아닌) 외둥이[단일아]&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;싱글톤 패턴 정의.
    &lt;ul&gt;
      &lt;li&gt;클래스의 인스턴스를 하나만 생성하고, 어디서든 그 인스턴스를 참조할 수 있도록 하는 패턴.&lt;/li&gt;
      &lt;li&gt;여러 컴퓨터에서 프린터 한 대를 공유하는 경우, 한 대의 컴퓨터에서 프린트하고 있을 때 다른 컴퓨터가 프린트 명령을 내려도 현재 프린트하는 작업을 마치고 그다음 프린트를 해야지 두 작업이 섞여 나오면 문제가 될 것이다. 즉 여러 클라이언트(컴퓨터)가 동일 객체(공유 프린터)를 사용하지만 한 개의 객체(프린트 명령을 받은 출력물)가 유일하도록 상위 객체가 보장하지 못한다면 singleton 패턴을 적용해야 한다. 이처럼 동일한 자원이나 데이터를 처리하는 객체가 불필요하게 여러 개 만들어질 필요가 없는 경우에 주로 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;싱글턴 패턴을 쓰는 이유?
    &lt;ul&gt;
      &lt;li&gt;고정된 메모리 영역을 가지고 하나의 인스턴스만 사용하기 때문에 메모리 낭비 방지&lt;/li&gt;
      &lt;li&gt;싱글턴 클래스의 인스턴스는 전역이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉬움&lt;/li&gt;
      &lt;li&gt;DBCP(DataBase Connection Pool) 처럼 공통된 객체를 여러 개 생성해야 하는 상황에 많이 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;싱글턴 구현
    &lt;ul&gt;
      &lt;li&gt;Eager initializaion
        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EagerSington&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EagerSington&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EagerSington&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

          &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;EagerSington&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

          &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EagerSington&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;ul&gt;
          &lt;li&gt;클라이언트에서 사용하지 않더라도 인스턴스가 항상 생성됨&lt;/li&gt;
          &lt;li&gt;예외 처리를 할 수 있는 방법이 없음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Static block initializaion
        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StaticBlockSingleton&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StaticBlockSingleton&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

          &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;instace&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StaticBlockSingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RuntimeException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;싱글톤 객체 생성 오류&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StaticBlockSingleton&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;ul&gt;
          &lt;li&gt;Eager initializaion과 유사, 인스턴스가  static block 내에서 생성됨.&lt;/li&gt;
          &lt;li&gt;예외 처리 가능&lt;/li&gt;
          &lt;li&gt;처음  시작할 때 초기화 되어 메모리 낭비 유발.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Lazy initializaion
        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.Objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LazyInitializaitonSingletion&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LazyInitializaitonSingletion&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

          &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LazyInitializaitonSingletion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;

          &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LazyInitializaitonSingletion&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;instace&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LazyInitializaitonSingletion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;ul&gt;
          &lt;li&gt;getInctace() 호출 이외에는 인스턴스를 생성하지 않음.&lt;/li&gt;
          &lt;li&gt;Eager initializaion의 단점을 보완&lt;/li&gt;
          &lt;li&gt;Thread safety 하지 않음.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Tread safe initializaion
        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadSafeSington&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadSafeSington&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

          &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ThreadSafeSington&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;

          &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadSafeSington&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadSafeSington&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;ul&gt;
          &lt;li&gt;synchronized를 이용해서 하나의 스레드만 접근 가능하도록 설정&lt;/li&gt;
          &lt;li&gt;성능 저하를 야기하는 비효율적인 방법(느리다.)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Double-Checked Locking
        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StaticBlockSingleton&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StaticBlockSingleton&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

          &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;instace&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StaticBlockSingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RuntimeException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;싱글톤 객체 생성 오류&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StaticBlockSingleton&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;ul&gt;
          &lt;li&gt;Null 체크를 synchronized 블록 밖에서 한번, 안에서 한번 총 두 번 실행&lt;/li&gt;
          &lt;li&gt;밖에서 하는 체크는 인스턴스가 있는 경우 빠르게 리턴하기 위해서 안쪽에서 하는 체크는 인스턴스가 생성되지 않은 경우 하나의 인스턴스만 생성하기 위해.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Bill Pugh Solution
        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BillPughSingleton&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;BillPughSingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

          &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SingletonHelper&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BillPughSingleton&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instace&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BillPughSingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

          &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BillPughSingleton&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SingletonHelper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;instace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;ul&gt;
          &lt;li&gt;Double Checked에 비해 구현이 간단.&lt;/li&gt;
          &lt;li&gt;Lazy Loding이 가능&lt;/li&gt;
          &lt;li&gt;Thread safety&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Thread safety : 멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 뜻한다. 보다 엄밀하게는 하나의 함수가 한 스레드로부터 호출되어 실행 중일 때, 다른 스레드가 그 함수를 호출하여 동시에 함께 실행되더라도 각 스레드에서의 함수의 수행 결과가 올바로 나오는 것으로 정의한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html">목표 : 싱글톤 패턴에 대해서 공부하여 자료를 만들고 스터디 그룹에서 발표한다.</summary></entry><entry><title type="html">02장 도메인 논리 구성</title><link href="http://localhost:4000/jekyll/update/2021/11/17/2%EC%9E%A5.html" rel="alternate" type="text/html" title="02장 도메인 논리 구성" /><published>2021-11-17T10:06:03+09:00</published><updated>2021-11-17T10:06:03+09:00</updated><id>http://localhost:4000/jekyll/update/2021/11/17/2%EC%9E%A5</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2021/11/17/2%EC%9E%A5.html">&lt;ol&gt;
  &lt;li&gt;도메인 논리의 3가지 주요 패턴
    &lt;ul&gt;
      &lt;li&gt;트랜잭션 스크립트 : 사용자가 수행할 각 작업마다 프로시저 하나씩 사용하는 방식.&lt;/li&gt;
      &lt;li&gt;도메인 모델 :   복잡한 논리 해결을 위한 객체 지향적 방법, 최종 객체가 결과를 내놓을때 까지 관련된 논리를 각 객체가 일부를 담당하는 방식.&lt;/li&gt;
      &lt;li&gt;테이블 모듈 : 트랜잭션 스크립트와 도메인 모델의 중간적인 성격, 데이터 베이스에 쿼리를 수행해 레코드 집합을 얻고 레코드 집한을 인수로 전달해 객체를 만들어 작업을 수행.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;트랜잭션 스크립트
    &lt;ul&gt;
      &lt;li&gt;장점
        &lt;ul&gt;
          &lt;li&gt;대부분의 개발자가 이해할 수 있는 간단한 절차적 모델&lt;/li&gt;
          &lt;li&gt;행 데이터 게이트웨이나 테이블 데이터 게이트웨이를 적용해 데이터 원본 계층과 함께 사용하기에 적합&lt;/li&gt;
          &lt;li&gt;트랜잭션의 경계를 설정하기가 쉽다. 트랜잭션 열기와 함께 시작되고 트랜잭션 닫기와 함께 종료된다. 툴을 사용해 배후에서 이러한 작업을 하기도 쉽다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;단점
        &lt;ul&gt;
          &lt;li&gt;도메인 논리가 늘어나면 복잡도가 상승&lt;/li&gt;
          &lt;li&gt;여러 트랜잭션이 비슷한 작업을 수행해야 하므로 코드가 많이 중복됨.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;도메인 모델
    &lt;ul&gt;
      &lt;li&gt;장점
        &lt;ul&gt;
          &lt;li&gt;복잡한 논리를 체계적으로 관리할 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;단점
        &lt;ul&gt;
          &lt;li&gt;데이터 원본 계층의 복잡성으로 좋은 데이터 원본 계층을 확보하는데 비용과 시간이 필요.&lt;/li&gt;
          &lt;li&gt;사용의 복잡성 으로 리치 객체 모델을 처음 시작하는 개발자가 도메인 모델에 익숙해 지는데 시간이 필요.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;테이블 모듈
    &lt;ul&gt;
      &lt;li&gt;장점
        &lt;ul&gt;
          &lt;li&gt;테이블 기준으로 도메인 논리를 구성하기 때문에 구조를 만들고 중복을 찾아 제거하기 수월&lt;/li&gt;
          &lt;li&gt;아키텍처의 나머지 부분과 잘 맞음. (ex : 여러 GUI  환경에서 SQL 쿼리 결과를 활용)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;단점
        &lt;ul&gt;
          &lt;li&gt;상속, 전략, 다른 객체지향 패턴과 같이 논리의 세부 구조를 만드는 데 사용하는 여러 기법은 사용할 수  없다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;도메인 논리 선택
    &lt;ul&gt;
      &lt;li&gt;도메인 논리가 간단하면 도메인 모델 효율이 떨어지고 반대로 도메인 논리가 복잡하면 트랜잭션 스크립트와 테이블 모듈 효율성이 떨이짐.&lt;/li&gt;
      &lt;li&gt;테이블 모듈에 대한 선호도는 환경에서 레코드 집합을 얼마나 잘 지원 하느냐에 따라 결정(.NEW, 비쥬얼 스튜디오 같은 환경에서 유리)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서비스 계층
    &lt;ul&gt;
      &lt;li&gt;도메인 논리를 처리하는 일반적인 방법 : 도메인 계층을 둘로 나누어 서비스 계층을 기반이 되는 도메인 모델이나 테이블 모듈 위에 배치.&lt;/li&gt;
      &lt;li&gt;트랜잭션 스크립트만 사용하는 도메인 계층은 복잡하지 않기 때문에  도메인 모델이나 테이블 모듈에만 사용.?&lt;/li&gt;
      &lt;li&gt;서비스 계층 사용 형식1 : 가장 소극적 사례로, 서비스 계층을 파사드로 만들고 모든 실제 동작을 기반 객체에 넣은 다음 서비스 계층이 파사드에 대한 호출을 하위 객체로 전달하게 하는것&lt;/li&gt;
      &lt;li&gt;서비스 계층 사용 형식2 : 형식 1과  반대되는 극단적 사례, 대부분의 비즈니스 논리를 서비스 계층 안에 트랜잭션 스크립트를 넣는 것.&lt;/li&gt;
      &lt;li&gt;컨트롤러-엔티티 형식 : 형식 1과, 형식 2의 중간적인 성격, 한 트랜잭션이나 유스 케이스에 적용되는 논리를 트랜잭션 스크립트에 넣는 것이며 일반적으로 컨트롤러나 서비스라고 한다.
    - 파사드 패턴 : Facade는 “건물의 정면”을 의미하는 단어로 어떤 소프트웨어의 다른 커다란 코드 부분에 대하여 간략화된 인터페이스를 제공해주는 디자인 패턴을 의미합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html">도메인 논리의 3가지 주요 패턴 트랜잭션 스크립트 : 사용자가 수행할 각 작업마다 프로시저 하나씩 사용하는 방식. 도메인 모델 : 복잡한 논리 해결을 위한 객체 지향적 방법, 최종 객체가 결과를 내놓을때 까지 관련된 논리를 각 객체가 일부를 담당하는 방식. 테이블 모듈 : 트랜잭션 스크립트와 도메인 모델의 중간적인 성격, 데이터 베이스에 쿼리를 수행해 레코드 집합을 얻고 레코드 집한을 인수로 전달해 객체를 만들어 작업을 수행. 트랜잭션 스크립트 장점 대부분의 개발자가 이해할 수 있는 간단한 절차적 모델 행 데이터 게이트웨이나 테이블 데이터 게이트웨이를 적용해 데이터 원본 계층과 함께 사용하기에 적합 트랜잭션의 경계를 설정하기가 쉽다. 트랜잭션 열기와 함께 시작되고 트랜잭션 닫기와 함께 종료된다. 툴을 사용해 배후에서 이러한 작업을 하기도 쉽다. 단점 도메인 논리가 늘어나면 복잡도가 상승 여러 트랜잭션이 비슷한 작업을 수행해야 하므로 코드가 많이 중복됨. 도메인 모델 장점 복잡한 논리를 체계적으로 관리할 수 있다. 단점 데이터 원본 계층의 복잡성으로 좋은 데이터 원본 계층을 확보하는데 비용과 시간이 필요. 사용의 복잡성 으로 리치 객체 모델을 처음 시작하는 개발자가 도메인 모델에 익숙해 지는데 시간이 필요. 테이블 모듈 장점 테이블 기준으로 도메인 논리를 구성하기 때문에 구조를 만들고 중복을 찾아 제거하기 수월 아키텍처의 나머지 부분과 잘 맞음. (ex : 여러 GUI 환경에서 SQL 쿼리 결과를 활용) 단점 상속, 전략, 다른 객체지향 패턴과 같이 논리의 세부 구조를 만드는 데 사용하는 여러 기법은 사용할 수 없다. 도메인 논리 선택 도메인 논리가 간단하면 도메인 모델 효율이 떨어지고 반대로 도메인 논리가 복잡하면 트랜잭션 스크립트와 테이블 모듈 효율성이 떨이짐. 테이블 모듈에 대한 선호도는 환경에서 레코드 집합을 얼마나 잘 지원 하느냐에 따라 결정(.NEW, 비쥬얼 스튜디오 같은 환경에서 유리) 서비스 계층 도메인 논리를 처리하는 일반적인 방법 : 도메인 계층을 둘로 나누어 서비스 계층을 기반이 되는 도메인 모델이나 테이블 모듈 위에 배치. 트랜잭션 스크립트만 사용하는 도메인 계층은 복잡하지 않기 때문에 도메인 모델이나 테이블 모듈에만 사용.? 서비스 계층 사용 형식1 : 가장 소극적 사례로, 서비스 계층을 파사드로 만들고 모든 실제 동작을 기반 객체에 넣은 다음 서비스 계층이 파사드에 대한 호출을 하위 객체로 전달하게 하는것 서비스 계층 사용 형식2 : 형식 1과 반대되는 극단적 사례, 대부분의 비즈니스 논리를 서비스 계층 안에 트랜잭션 스크립트를 넣는 것. 컨트롤러-엔티티 형식 : 형식 1과, 형식 2의 중간적인 성격, 한 트랜잭션이나 유스 케이스에 적용되는 논리를 트랜잭션 스크립트에 넣는 것이며 일반적으로 컨트롤러나 서비스라고 한다. - 파사드 패턴 : Facade는 “건물의 정면”을 의미하는 단어로 어떤 소프트웨어의 다른 커다란 코드 부분에 대하여 간략화된 인터페이스를 제공해주는 디자인 패턴을 의미합니다.</summary></entry></feed>