<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>02장 도메인 논리 구성 | 임정찬의 블로그</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="02장 도메인 논리 구성" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="도메인 논리의 3가지 주요 패턴 트랜잭션 스크립트 : 사용자가 수행할 각 작업마다 프로시저 하나씩 사용하는 방식. 도메인 모델 : 복잡한 논리 해결을 위한 객체 지향적 방법, 최종 객체가 결과를 내놓을때 까지 관련된 논리를 각 객체가 일부를 담당하는 방식. 테이블 모듈 : 트랜잭션 스크립트와 도메인 모델의 중간적인 성격, 데이터 베이스에 쿼리를 수행해 레코드 집합을 얻고 레코드 집한을 인수로 전달해 객체를 만들어 작업을 수행. 트랜잭션 스크립트 장점 대부분의 개발자가 이해할 수 있는 간단한 절차적 모델 행 데이터 게이트웨이나 테이블 데이터 게이트웨이를 적용해 데이터 원본 계층과 함께 사용하기에 적합 트랜잭션의 경계를 설정하기가 쉽다. 트랜잭션 열기와 함께 시작되고 트랜잭션 닫기와 함께 종료된다. 툴을 사용해 배후에서 이러한 작업을 하기도 쉽다. 단점 도메인 논리가 늘어나면 복잡도가 상승 여러 트랜잭션이 비슷한 작업을 수행해야 하므로 코드가 많이 중복됨. 도메인 모델 장점 복잡한 논리를 체계적으로 관리할 수 있다. 단점 데이터 원본 계층의 복잡성으로 좋은 데이터 원본 계층을 확보하는데 비용과 시간이 필요. 사용의 복잡성 으로 리치 객체 모델을 처음 시작하는 개발자가 도메인 모델에 익숙해 지는데 시간이 필요. 테이블 모듈 장점 테이블 기준으로 도메인 논리를 구성하기 때문에 구조를 만들고 중복을 찾아 제거하기 수월 아키텍처의 나머지 부분과 잘 맞음. (ex : 여러 GUI 환경에서 SQL 쿼리 결과를 활용) 단점 상속, 전략, 다른 객체지향 패턴과 같이 논리의 세부 구조를 만드는 데 사용하는 여러 기법은 사용할 수 없다. 도메인 논리 선택 도메인 논리가 간단하면 도메인 모델 효율이 떨어지고 반대로 도메인 논리가 복잡하면 트랜잭션 스크립트와 테이블 모듈 효율성이 떨이짐. 테이블 모듈에 대한 선호도는 환경에서 레코드 집합을 얼마나 잘 지원 하느냐에 따라 결정(.NEW, 비쥬얼 스튜디오 같은 환경에서 유리) 서비스 계층 도메인 논리를 처리하는 일반적인 방법 : 도메인 계층을 둘로 나누어 서비스 계층을 기반이 되는 도메인 모델이나 테이블 모듈 위에 배치. 트랜잭션 스크립트만 사용하는 도메인 계층은 복잡하지 않기 때문에 도메인 모델이나 테이블 모듈에만 사용.? 서비스 계층 사용 형식1 : 가장 소극적 사례로, 서비스 계층을 파사드로 만들고 모든 실제 동작을 기반 객체에 넣은 다음 서비스 계층이 파사드에 대한 호출을 하위 객체로 전달하게 하는것 서비스 계층 사용 형식2 : 형식 1과 반대되는 극단적 사례, 대부분의 비즈니스 논리를 서비스 계층 안에 트랜잭션 스크립트를 넣는 것. 컨트롤러-엔티티 형식 : 형식 1과, 형식 2의 중간적인 성격, 한 트랜잭션이나 유스 케이스에 적용되는 논리를 트랜잭션 스크립트에 넣는 것이며 일반적으로 컨트롤러나 서비스라고 한다. - 파사드 패턴 : Facade는 “건물의 정면”을 의미하는 단어로 어떤 소프트웨어의 다른 커다란 코드 부분에 대하여 간략화된 인터페이스를 제공해주는 디자인 패턴을 의미합니다." />
<meta property="og:description" content="도메인 논리의 3가지 주요 패턴 트랜잭션 스크립트 : 사용자가 수행할 각 작업마다 프로시저 하나씩 사용하는 방식. 도메인 모델 : 복잡한 논리 해결을 위한 객체 지향적 방법, 최종 객체가 결과를 내놓을때 까지 관련된 논리를 각 객체가 일부를 담당하는 방식. 테이블 모듈 : 트랜잭션 스크립트와 도메인 모델의 중간적인 성격, 데이터 베이스에 쿼리를 수행해 레코드 집합을 얻고 레코드 집한을 인수로 전달해 객체를 만들어 작업을 수행. 트랜잭션 스크립트 장점 대부분의 개발자가 이해할 수 있는 간단한 절차적 모델 행 데이터 게이트웨이나 테이블 데이터 게이트웨이를 적용해 데이터 원본 계층과 함께 사용하기에 적합 트랜잭션의 경계를 설정하기가 쉽다. 트랜잭션 열기와 함께 시작되고 트랜잭션 닫기와 함께 종료된다. 툴을 사용해 배후에서 이러한 작업을 하기도 쉽다. 단점 도메인 논리가 늘어나면 복잡도가 상승 여러 트랜잭션이 비슷한 작업을 수행해야 하므로 코드가 많이 중복됨. 도메인 모델 장점 복잡한 논리를 체계적으로 관리할 수 있다. 단점 데이터 원본 계층의 복잡성으로 좋은 데이터 원본 계층을 확보하는데 비용과 시간이 필요. 사용의 복잡성 으로 리치 객체 모델을 처음 시작하는 개발자가 도메인 모델에 익숙해 지는데 시간이 필요. 테이블 모듈 장점 테이블 기준으로 도메인 논리를 구성하기 때문에 구조를 만들고 중복을 찾아 제거하기 수월 아키텍처의 나머지 부분과 잘 맞음. (ex : 여러 GUI 환경에서 SQL 쿼리 결과를 활용) 단점 상속, 전략, 다른 객체지향 패턴과 같이 논리의 세부 구조를 만드는 데 사용하는 여러 기법은 사용할 수 없다. 도메인 논리 선택 도메인 논리가 간단하면 도메인 모델 효율이 떨어지고 반대로 도메인 논리가 복잡하면 트랜잭션 스크립트와 테이블 모듈 효율성이 떨이짐. 테이블 모듈에 대한 선호도는 환경에서 레코드 집합을 얼마나 잘 지원 하느냐에 따라 결정(.NEW, 비쥬얼 스튜디오 같은 환경에서 유리) 서비스 계층 도메인 논리를 처리하는 일반적인 방법 : 도메인 계층을 둘로 나누어 서비스 계층을 기반이 되는 도메인 모델이나 테이블 모듈 위에 배치. 트랜잭션 스크립트만 사용하는 도메인 계층은 복잡하지 않기 때문에 도메인 모델이나 테이블 모듈에만 사용.? 서비스 계층 사용 형식1 : 가장 소극적 사례로, 서비스 계층을 파사드로 만들고 모든 실제 동작을 기반 객체에 넣은 다음 서비스 계층이 파사드에 대한 호출을 하위 객체로 전달하게 하는것 서비스 계층 사용 형식2 : 형식 1과 반대되는 극단적 사례, 대부분의 비즈니스 논리를 서비스 계층 안에 트랜잭션 스크립트를 넣는 것. 컨트롤러-엔티티 형식 : 형식 1과, 형식 2의 중간적인 성격, 한 트랜잭션이나 유스 케이스에 적용되는 논리를 트랜잭션 스크립트에 넣는 것이며 일반적으로 컨트롤러나 서비스라고 한다. - 파사드 패턴 : Facade는 “건물의 정면”을 의미하는 단어로 어떤 소프트웨어의 다른 커다란 코드 부분에 대하여 간략화된 인터페이스를 제공해주는 디자인 패턴을 의미합니다." />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2021/11/17/2%EC%9E%A5.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2021/11/17/2%EC%9E%A5.html" />
<meta property="og:site_name" content="임정찬의 블로그" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-11-17T10:06:03+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="02장 도메인 논리 구성" />
<script type="application/ld+json">
{"headline":"02장 도메인 논리 구성","dateModified":"2021-11-17T10:06:03+09:00","datePublished":"2021-11-17T10:06:03+09:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2021/11/17/2%EC%9E%A5.html"},"description":"도메인 논리의 3가지 주요 패턴 트랜잭션 스크립트 : 사용자가 수행할 각 작업마다 프로시저 하나씩 사용하는 방식. 도메인 모델 : 복잡한 논리 해결을 위한 객체 지향적 방법, 최종 객체가 결과를 내놓을때 까지 관련된 논리를 각 객체가 일부를 담당하는 방식. 테이블 모듈 : 트랜잭션 스크립트와 도메인 모델의 중간적인 성격, 데이터 베이스에 쿼리를 수행해 레코드 집합을 얻고 레코드 집한을 인수로 전달해 객체를 만들어 작업을 수행. 트랜잭션 스크립트 장점 대부분의 개발자가 이해할 수 있는 간단한 절차적 모델 행 데이터 게이트웨이나 테이블 데이터 게이트웨이를 적용해 데이터 원본 계층과 함께 사용하기에 적합 트랜잭션의 경계를 설정하기가 쉽다. 트랜잭션 열기와 함께 시작되고 트랜잭션 닫기와 함께 종료된다. 툴을 사용해 배후에서 이러한 작업을 하기도 쉽다. 단점 도메인 논리가 늘어나면 복잡도가 상승 여러 트랜잭션이 비슷한 작업을 수행해야 하므로 코드가 많이 중복됨. 도메인 모델 장점 복잡한 논리를 체계적으로 관리할 수 있다. 단점 데이터 원본 계층의 복잡성으로 좋은 데이터 원본 계층을 확보하는데 비용과 시간이 필요. 사용의 복잡성 으로 리치 객체 모델을 처음 시작하는 개발자가 도메인 모델에 익숙해 지는데 시간이 필요. 테이블 모듈 장점 테이블 기준으로 도메인 논리를 구성하기 때문에 구조를 만들고 중복을 찾아 제거하기 수월 아키텍처의 나머지 부분과 잘 맞음. (ex : 여러 GUI 환경에서 SQL 쿼리 결과를 활용) 단점 상속, 전략, 다른 객체지향 패턴과 같이 논리의 세부 구조를 만드는 데 사용하는 여러 기법은 사용할 수 없다. 도메인 논리 선택 도메인 논리가 간단하면 도메인 모델 효율이 떨어지고 반대로 도메인 논리가 복잡하면 트랜잭션 스크립트와 테이블 모듈 효율성이 떨이짐. 테이블 모듈에 대한 선호도는 환경에서 레코드 집합을 얼마나 잘 지원 하느냐에 따라 결정(.NEW, 비쥬얼 스튜디오 같은 환경에서 유리) 서비스 계층 도메인 논리를 처리하는 일반적인 방법 : 도메인 계층을 둘로 나누어 서비스 계층을 기반이 되는 도메인 모델이나 테이블 모듈 위에 배치. 트랜잭션 스크립트만 사용하는 도메인 계층은 복잡하지 않기 때문에 도메인 모델이나 테이블 모듈에만 사용.? 서비스 계층 사용 형식1 : 가장 소극적 사례로, 서비스 계층을 파사드로 만들고 모든 실제 동작을 기반 객체에 넣은 다음 서비스 계층이 파사드에 대한 호출을 하위 객체로 전달하게 하는것 서비스 계층 사용 형식2 : 형식 1과 반대되는 극단적 사례, 대부분의 비즈니스 논리를 서비스 계층 안에 트랜잭션 스크립트를 넣는 것. 컨트롤러-엔티티 형식 : 형식 1과, 형식 2의 중간적인 성격, 한 트랜잭션이나 유스 케이스에 적용되는 논리를 트랜잭션 스크립트에 넣는 것이며 일반적으로 컨트롤러나 서비스라고 한다. - 파사드 패턴 : Facade는 “건물의 정면”을 의미하는 단어로 어떤 소프트웨어의 다른 커다란 코드 부분에 대하여 간략화된 인터페이스를 제공해주는 디자인 패턴을 의미합니다.","url":"http://localhost:4000/jekyll/update/2021/11/17/2%EC%9E%A5.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="임정찬의 블로그" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">임정찬의 블로그</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">02장 도메인 논리 구성</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2021-11-17T10:06:03+09:00" itemprop="datePublished">Nov 17, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ol>
  <li>도메인 논리의 3가지 주요 패턴
    <ul>
      <li>트랜잭션 스크립트 : 사용자가 수행할 각 작업마다 프로시저 하나씩 사용하는 방식.</li>
      <li>도메인 모델 :   복잡한 논리 해결을 위한 객체 지향적 방법, 최종 객체가 결과를 내놓을때 까지 관련된 논리를 각 객체가 일부를 담당하는 방식.</li>
      <li>테이블 모듈 : 트랜잭션 스크립트와 도메인 모델의 중간적인 성격, 데이터 베이스에 쿼리를 수행해 레코드 집합을 얻고 레코드 집한을 인수로 전달해 객체를 만들어 작업을 수행.</li>
    </ul>
  </li>
  <li>트랜잭션 스크립트
    <ul>
      <li>장점
        <ul>
          <li>대부분의 개발자가 이해할 수 있는 간단한 절차적 모델</li>
          <li>행 데이터 게이트웨이나 테이블 데이터 게이트웨이를 적용해 데이터 원본 계층과 함께 사용하기에 적합</li>
          <li>트랜잭션의 경계를 설정하기가 쉽다. 트랜잭션 열기와 함께 시작되고 트랜잭션 닫기와 함께 종료된다. 툴을 사용해 배후에서 이러한 작업을 하기도 쉽다.</li>
        </ul>
      </li>
      <li>단점
        <ul>
          <li>도메인 논리가 늘어나면 복잡도가 상승</li>
          <li>여러 트랜잭션이 비슷한 작업을 수행해야 하므로 코드가 많이 중복됨.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>도메인 모델
    <ul>
      <li>장점
        <ul>
          <li>복잡한 논리를 체계적으로 관리할 수 있다.</li>
        </ul>
      </li>
      <li>단점
        <ul>
          <li>데이터 원본 계층의 복잡성으로 좋은 데이터 원본 계층을 확보하는데 비용과 시간이 필요.</li>
          <li>사용의 복잡성 으로 리치 객체 모델을 처음 시작하는 개발자가 도메인 모델에 익숙해 지는데 시간이 필요.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>테이블 모듈
    <ul>
      <li>장점
        <ul>
          <li>테이블 기준으로 도메인 논리를 구성하기 때문에 구조를 만들고 중복을 찾아 제거하기 수월</li>
          <li>아키텍처의 나머지 부분과 잘 맞음. (ex : 여러 GUI  환경에서 SQL 쿼리 결과를 활용)</li>
        </ul>
      </li>
      <li>단점
        <ul>
          <li>상속, 전략, 다른 객체지향 패턴과 같이 논리의 세부 구조를 만드는 데 사용하는 여러 기법은 사용할 수  없다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>도메인 논리 선택
    <ul>
      <li>도메인 논리가 간단하면 도메인 모델 효율이 떨어지고 반대로 도메인 논리가 복잡하면 트랜잭션 스크립트와 테이블 모듈 효율성이 떨이짐.</li>
      <li>테이블 모듈에 대한 선호도는 환경에서 레코드 집합을 얼마나 잘 지원 하느냐에 따라 결정(.NEW, 비쥬얼 스튜디오 같은 환경에서 유리)</li>
    </ul>
  </li>
  <li>서비스 계층
    <ul>
      <li>도메인 논리를 처리하는 일반적인 방법 : 도메인 계층을 둘로 나누어 서비스 계층을 기반이 되는 도메인 모델이나 테이블 모듈 위에 배치.</li>
      <li>트랜잭션 스크립트만 사용하는 도메인 계층은 복잡하지 않기 때문에  도메인 모델이나 테이블 모듈에만 사용.?</li>
      <li>서비스 계층 사용 형식1 : 가장 소극적 사례로, 서비스 계층을 파사드로 만들고 모든 실제 동작을 기반 객체에 넣은 다음 서비스 계층이 파사드에 대한 호출을 하위 객체로 전달하게 하는것</li>
      <li>서비스 계층 사용 형식2 : 형식 1과  반대되는 극단적 사례, 대부분의 비즈니스 논리를 서비스 계층 안에 트랜잭션 스크립트를 넣는 것.</li>
      <li>컨트롤러-엔티티 형식 : 형식 1과, 형식 2의 중간적인 성격, 한 트랜잭션이나 유스 케이스에 적용되는 논리를 트랜잭션 스크립트에 넣는 것이며 일반적으로 컨트롤러나 서비스라고 한다.
    - 파사드 패턴 : Facade는 “건물의 정면”을 의미하는 단어로 어떤 소프트웨어의 다른 커다란 코드 부분에 대하여 간략화된 인터페이스를 제공해주는 디자인 패턴을 의미합니다.</li>
    </ul>
  </li>
</ol>

  </div><a class="u-url" href="/jekyll/update/2021/11/17/2%EC%9E%A5.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">임정찬의 블로그</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">임정찬의 블로그</li><li><a class="u-email" href="mailto:vibrissa@starlabs.co.kr">vibrissa@starlabs.co.kr</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/LimJeongchan"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">LimJeongchan</span></a></li><li><a href="https://www.twitter.com/vibrissa"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">vibrissa</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
