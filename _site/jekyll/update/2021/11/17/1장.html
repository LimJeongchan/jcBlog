<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>01장 계층화 | 임정찬의 블로그</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="01장 계층화" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="계층화 정의 : 소프트웨어 설계자가 복잡한 소프트웨어 시스템을 분할하는 데 사용하는 가장 일반적인 기법. 계층화의 장점 다른 계층에 대한 정보 없이도 단일 계층을 하나의 일관된 계층으로 이해할 수 있다. 동일한 기본 서비스를 가진 대안 구현으로 계층을 대체할 수 있다. 계층 간의 의존성을 최소화할 수 있다. 계층은 표준화하기 좋은 위치다. 한번 구축한 계층은 여러 다른 상위 서비스에서 사용할 수 있다. 계층화의 단점 계층은 전체가 효과적으로 캡슐화되지 않는다. 그 결과, 뭔가를 변경했을 때 다른 계층에 영향을 미치는 경우가 있다. 계층을 추가하면 성능이 저하된다. 엔터프라이즈 애플리케이션에서 계층의 발전 일괄 처리 시스템 이시절 계층화는 그리 중요한 개념이 아님, ISAMS, VSAM등 파일을 조작하는 것으로 충분했기 때문 90년대 클라이언트-서버 시스템의 등장 클라이언트-서버 시스템이란 클라이언트가 사용자 인터페이스와 다른 애플리케이션 코드를 포함하고 서버가 관계형 데이터베이스를 포함하는 2계층 시스템 단순 업데이트 하는 간단한 기능을 수행하는데 적합. 문제점 1 : 도메인 논리(계산, 유효성 검사, 계산 등) 변경이 이루어 졌을 때 수많은 코드를 찾아야 함. 문제점 2: 문제점 1대안으로 프로시저를 만들었는데 프로시저는 공급 업체별로 다르기 때문에 종속성 문제가 발생. 객체지향 세계의 시작과 웹의 등장 객체지향 커뮤니티에서 도메인 논리에 대한 해결책으로 3계층 시스템을 제안. 웹의 등장으로 웹배포를 위한 3계층 시스템 도입이 필요하게 되었다. 티어 : 물리적 분리를 함축하는 경우. (ex : 클라이언트-서버 시스템 은 2계층) 계층 : 다른시스템에서 실행할 필요가 없음을 강조하기 위해 계층이라는 용어를 사용 세 가지 주요 계층 프레젠테이션 :서비스 제공, 정보 표시(창 또는 HTML), 사용자 요청(마우스 클릭, 키누름), HTTP 요청, 명령줄 호출, 일괄 작업 API 처리 도메인 : 시스템의 핵심이 되는 논리 데이터 원본 : 데이터 베이스, 메시징 시스템, 트랜잭션 관리자 및 다른 패키지와 의 통신 계층이 실행될 위치 선택 서버에서 모든걸 실행했을 때의 장점 업그레이드나 수정이 쉽다. 데스크톱 서버 동기화를 신경쓰지 않아도 된다. 다른 데스크톱 소프트웨어와의 호환성 문제도 없다. 클라이언트에서 모든걸 실행했을 때의 장점 응답성이나 비연결 작업이 유리함. 계층별로 실행 할 수 있는 위치 선택 프레젠테이션 계층 : 사용자 인터페이스의 유형에 따라 달라진다. 리치 클라이언트의 경우 대부분 클라이언트에서 실행, 웹 인터페이스의 경우 거의 대부분 서버에서 실행. 특별한 사유가 없으면 웹에서 실행되는 프레젠 테이션을 권장. 도메인 논리 계층 : 서버 , 클라이언트 모두 실행 가능 하나 서버에서 실행하는 것이 유지 관리를 생각할 때 최선의 방법 모든 논리를 한곳에서 관리 할 수 있기 때문. 일부 클라이언트에서 실행할 경우 다른 시스템에 의존하지 않는 독립적 모듈로 만들 것." />
<meta property="og:description" content="계층화 정의 : 소프트웨어 설계자가 복잡한 소프트웨어 시스템을 분할하는 데 사용하는 가장 일반적인 기법. 계층화의 장점 다른 계층에 대한 정보 없이도 단일 계층을 하나의 일관된 계층으로 이해할 수 있다. 동일한 기본 서비스를 가진 대안 구현으로 계층을 대체할 수 있다. 계층 간의 의존성을 최소화할 수 있다. 계층은 표준화하기 좋은 위치다. 한번 구축한 계층은 여러 다른 상위 서비스에서 사용할 수 있다. 계층화의 단점 계층은 전체가 효과적으로 캡슐화되지 않는다. 그 결과, 뭔가를 변경했을 때 다른 계층에 영향을 미치는 경우가 있다. 계층을 추가하면 성능이 저하된다. 엔터프라이즈 애플리케이션에서 계층의 발전 일괄 처리 시스템 이시절 계층화는 그리 중요한 개념이 아님, ISAMS, VSAM등 파일을 조작하는 것으로 충분했기 때문 90년대 클라이언트-서버 시스템의 등장 클라이언트-서버 시스템이란 클라이언트가 사용자 인터페이스와 다른 애플리케이션 코드를 포함하고 서버가 관계형 데이터베이스를 포함하는 2계층 시스템 단순 업데이트 하는 간단한 기능을 수행하는데 적합. 문제점 1 : 도메인 논리(계산, 유효성 검사, 계산 등) 변경이 이루어 졌을 때 수많은 코드를 찾아야 함. 문제점 2: 문제점 1대안으로 프로시저를 만들었는데 프로시저는 공급 업체별로 다르기 때문에 종속성 문제가 발생. 객체지향 세계의 시작과 웹의 등장 객체지향 커뮤니티에서 도메인 논리에 대한 해결책으로 3계층 시스템을 제안. 웹의 등장으로 웹배포를 위한 3계층 시스템 도입이 필요하게 되었다. 티어 : 물리적 분리를 함축하는 경우. (ex : 클라이언트-서버 시스템 은 2계층) 계층 : 다른시스템에서 실행할 필요가 없음을 강조하기 위해 계층이라는 용어를 사용 세 가지 주요 계층 프레젠테이션 :서비스 제공, 정보 표시(창 또는 HTML), 사용자 요청(마우스 클릭, 키누름), HTTP 요청, 명령줄 호출, 일괄 작업 API 처리 도메인 : 시스템의 핵심이 되는 논리 데이터 원본 : 데이터 베이스, 메시징 시스템, 트랜잭션 관리자 및 다른 패키지와 의 통신 계층이 실행될 위치 선택 서버에서 모든걸 실행했을 때의 장점 업그레이드나 수정이 쉽다. 데스크톱 서버 동기화를 신경쓰지 않아도 된다. 다른 데스크톱 소프트웨어와의 호환성 문제도 없다. 클라이언트에서 모든걸 실행했을 때의 장점 응답성이나 비연결 작업이 유리함. 계층별로 실행 할 수 있는 위치 선택 프레젠테이션 계층 : 사용자 인터페이스의 유형에 따라 달라진다. 리치 클라이언트의 경우 대부분 클라이언트에서 실행, 웹 인터페이스의 경우 거의 대부분 서버에서 실행. 특별한 사유가 없으면 웹에서 실행되는 프레젠 테이션을 권장. 도메인 논리 계층 : 서버 , 클라이언트 모두 실행 가능 하나 서버에서 실행하는 것이 유지 관리를 생각할 때 최선의 방법 모든 논리를 한곳에서 관리 할 수 있기 때문. 일부 클라이언트에서 실행할 경우 다른 시스템에 의존하지 않는 독립적 모듈로 만들 것." />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2021/11/17/1%EC%9E%A5.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2021/11/17/1%EC%9E%A5.html" />
<meta property="og:site_name" content="임정찬의 블로그" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-11-17T13:51:03+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="01장 계층화" />
<script type="application/ld+json">
{"headline":"01장 계층화","dateModified":"2021-11-17T13:51:03+09:00","datePublished":"2021-11-17T13:51:03+09:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2021/11/17/1%EC%9E%A5.html"},"description":"계층화 정의 : 소프트웨어 설계자가 복잡한 소프트웨어 시스템을 분할하는 데 사용하는 가장 일반적인 기법. 계층화의 장점 다른 계층에 대한 정보 없이도 단일 계층을 하나의 일관된 계층으로 이해할 수 있다. 동일한 기본 서비스를 가진 대안 구현으로 계층을 대체할 수 있다. 계층 간의 의존성을 최소화할 수 있다. 계층은 표준화하기 좋은 위치다. 한번 구축한 계층은 여러 다른 상위 서비스에서 사용할 수 있다. 계층화의 단점 계층은 전체가 효과적으로 캡슐화되지 않는다. 그 결과, 뭔가를 변경했을 때 다른 계층에 영향을 미치는 경우가 있다. 계층을 추가하면 성능이 저하된다. 엔터프라이즈 애플리케이션에서 계층의 발전 일괄 처리 시스템 이시절 계층화는 그리 중요한 개념이 아님, ISAMS, VSAM등 파일을 조작하는 것으로 충분했기 때문 90년대 클라이언트-서버 시스템의 등장 클라이언트-서버 시스템이란 클라이언트가 사용자 인터페이스와 다른 애플리케이션 코드를 포함하고 서버가 관계형 데이터베이스를 포함하는 2계층 시스템 단순 업데이트 하는 간단한 기능을 수행하는데 적합. 문제점 1 : 도메인 논리(계산, 유효성 검사, 계산 등) 변경이 이루어 졌을 때 수많은 코드를 찾아야 함. 문제점 2: 문제점 1대안으로 프로시저를 만들었는데 프로시저는 공급 업체별로 다르기 때문에 종속성 문제가 발생. 객체지향 세계의 시작과 웹의 등장 객체지향 커뮤니티에서 도메인 논리에 대한 해결책으로 3계층 시스템을 제안. 웹의 등장으로 웹배포를 위한 3계층 시스템 도입이 필요하게 되었다. 티어 : 물리적 분리를 함축하는 경우. (ex : 클라이언트-서버 시스템 은 2계층) 계층 : 다른시스템에서 실행할 필요가 없음을 강조하기 위해 계층이라는 용어를 사용 세 가지 주요 계층 프레젠테이션 :서비스 제공, 정보 표시(창 또는 HTML), 사용자 요청(마우스 클릭, 키누름), HTTP 요청, 명령줄 호출, 일괄 작업 API 처리 도메인 : 시스템의 핵심이 되는 논리 데이터 원본 : 데이터 베이스, 메시징 시스템, 트랜잭션 관리자 및 다른 패키지와 의 통신 계층이 실행될 위치 선택 서버에서 모든걸 실행했을 때의 장점 업그레이드나 수정이 쉽다. 데스크톱 서버 동기화를 신경쓰지 않아도 된다. 다른 데스크톱 소프트웨어와의 호환성 문제도 없다. 클라이언트에서 모든걸 실행했을 때의 장점 응답성이나 비연결 작업이 유리함. 계층별로 실행 할 수 있는 위치 선택 프레젠테이션 계층 : 사용자 인터페이스의 유형에 따라 달라진다. 리치 클라이언트의 경우 대부분 클라이언트에서 실행, 웹 인터페이스의 경우 거의 대부분 서버에서 실행. 특별한 사유가 없으면 웹에서 실행되는 프레젠 테이션을 권장. 도메인 논리 계층 : 서버 , 클라이언트 모두 실행 가능 하나 서버에서 실행하는 것이 유지 관리를 생각할 때 최선의 방법 모든 논리를 한곳에서 관리 할 수 있기 때문. 일부 클라이언트에서 실행할 경우 다른 시스템에 의존하지 않는 독립적 모듈로 만들 것.","url":"http://localhost:4000/jekyll/update/2021/11/17/1%EC%9E%A5.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="임정찬의 블로그" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">임정찬의 블로그</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">01장 계층화</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2021-11-17T13:51:03+09:00" itemprop="datePublished">Nov 17, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ol>
  <li>계층화 정의 : 소프트웨어 설계자가 복잡한 소프트웨어 시스템을 분할하는 데 사용하는 가장 일반적인 기법.</li>
  <li>계층화의 장점
    <ul>
      <li>다른 계층에 대한 정보 없이도 단일 계층을 하나의 일관된 계층으로 이해할 수 있다.</li>
      <li>동일한 기본 서비스를 가진 대안 구현으로 계층을 대체할 수 있다.</li>
      <li>계층 간의 의존성을 최소화할 수 있다.</li>
      <li>계층은 표준화하기 좋은 위치다.</li>
      <li>한번 구축한 계층은 여러 다른 상위 서비스에서 사용할 수 있다.</li>
    </ul>
  </li>
  <li>계층화의 단점
    <ul>
      <li>계층은 전체가 효과적으로 캡슐화되지 않는다. 그 결과, 뭔가를 변경했을 때 다른 계층에 영향을 미치는 경우가 있다.</li>
      <li>계층을 추가하면 성능이 저하된다.</li>
    </ul>
  </li>
  <li>엔터프라이즈 애플리케이션에서 계층의 발전
    <ul>
      <li>일괄 처리 시스템
        <ul>
          <li>이시절 계층화는 그리 중요한 개념이 아님,  ISAMS, VSAM등 파일을 조작하는 것으로 충분했기 때문</li>
        </ul>
      </li>
      <li>90년대 클라이언트-서버 시스템의 등장
        <ul>
          <li>클라이언트-서버 시스템이란 클라이언트가 사용자 인터페이스와 다른 애플리케이션 코드를 포함하고 서버가 관계형 데이터베이스를 포함하는 2계층 시스템</li>
          <li>단순 업데이트 하는 간단한 기능을 수행하는데 적합.</li>
          <li>문제점 1 : 도메인 논리(계산, 유효성 검사, 계산 등) 변경이 이루어 졌을 때 수많은 코드를  찾아야 함.</li>
          <li>문제점 2: 문제점 1대안으로 프로시저를 만들었는데 프로시저는 공급 업체별로 다르기 때문에 종속성 문제가 발생.</li>
        </ul>
      </li>
      <li>객체지향 세계의 시작과 웹의 등장
        <ul>
          <li>객체지향 커뮤니티에서 도메인 논리에 대한 해결책으로 3계층 시스템을 제안.</li>
          <li>웹의 등장으로 웹배포를 위한 3계층 시스템 도입이 필요하게 되었다.
            <ul>
              <li>티어 : 물리적 분리를 함축하는 경우. (ex : 클라이언트-서버 시스템 은 2계층)</li>
              <li>계층 : 다른시스템에서 실행할 필요가 없음을 강조하기 위해 계층이라는 용어를 사용</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>세 가지 주요 계층
    <ul>
      <li>프레젠테이션 :서비스 제공, 정보 표시(창 또는 HTML),  사용자 요청(마우스 클릭, 키누름), HTTP 요청, 명령줄 호출, 일괄 작업 API 처리</li>
      <li>도메인 : 시스템의 핵심이 되는 논리</li>
      <li>데이터 원본 : 데이터 베이스, 메시징 시스템, 트랜잭션 관리자 및 다른 패키지와 의 통신</li>
    </ul>
  </li>
  <li>계층이 실행될 위치 선택
    <ul>
      <li>서버에서 모든걸 실행했을 때의 장점
        <ul>
          <li>업그레이드나 수정이 쉽다.</li>
          <li>데스크톱 서버 동기화를 신경쓰지 않아도 된다.</li>
          <li>다른 데스크톱 소프트웨어와의 호환성 문제도 없다.</li>
        </ul>
      </li>
      <li>클라이언트에서 모든걸 실행했을 때의 장점
        <ul>
          <li>응답성이나 비연결 작업이 유리함.</li>
        </ul>
      </li>
      <li>계층별로 실행 할 수 있는 위치 선택
        <ul>
          <li>프레젠테이션 계층 : 사용자 인터페이스의 유형에 따라 달라진다. 리치 클라이언트의 경우 대부분 클라이언트에서 실행, 웹 인터페이스의 경우 거의 대부분 서버에서 실행. 특별한 사유가 없으면 웹에서 실행되는 프레젠 테이션을 권장.</li>
          <li>도메인 논리 계층 : 서버 , 클라이언트 모두 실행 가능 하나 서버에서 실행하는 것이 유지 관리를 생각할 때 최선의 방법 모든 논리를 한곳에서 관리 할 수 있기 때문. 일부 클라이언트에서 실행할 경우 다른 시스템에 의존하지 않는 독립적 모듈로 만들 것.</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

  </div><a class="u-url" href="/jekyll/update/2021/11/17/1%EC%9E%A5.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">임정찬의 블로그</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">임정찬의 블로그</li><li><a class="u-email" href="mailto:vibrissa@starlabs.co.kr">vibrissa@starlabs.co.kr</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/LimJeongchan"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">LimJeongchan</span></a></li><li><a href="https://www.twitter.com/vibrissa"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">vibrissa</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
